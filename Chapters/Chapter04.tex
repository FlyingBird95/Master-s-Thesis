%************************************************
\chapter{Implementation}\label{ch:implementation}
%************************************************
This chapter explains the implementation of the proposed solution in \autoref{ch:design}. The first section of this chapter explains the relevant technologies with several details about the communication. Additionally, several decisions are described in \autoref{sec:decisions}. This chapter is finished with a deployed demo application which verifies the effectiveness of the implemented solution.

\section{Interface} \label{sec:interface}
As explained in \autoref{sec:architecture}, the proposed solution consists of three different types. This section provides an overview of each type and the communication between them.

\subsection{Root} \label{sec:impl-root}
The root contains the connect API which is used as an access point for other nodes. Its interface contains the following relevant endpoints:

\begin{itemize}
    \item \textbf{/root/add}: accepts POST-requests for adding nodes to keep track of. A node consists of an IP-address, including a port, and a boolean value indicating whether it is a super-node or a normal node.
    \item \textbf{/root/remove}: accepts POST-requests for removing nodes from the list. All properties from the previous endpoint must be equivalent before the node is removed. Additionally, this service pings every node once in a while to ensure that the node can still be accessed. If a node cannot be accessed for $X$ pings in a row (with an interval of $Y$ seconds), the node is removed from the list.
    \item \textbf{/root/distribution}: accepts a GET-request for returning the distribution. The endpoints returns therefore a list of all super-nodes with a list of all the nodes that are scraped by the super-nodes. Note that each super-node is also updated with the new distribution as soon as a new (super-)node is added to the list. 
\end{itemize}

\noindent
The root service is a rather small service as it only has to keep track of the available (super-)nodes and distribute them over the available super-nodes. This service is implemented at \url{https://github.com/dadvisor/root}. The root service also provides a dynamic configuration of the Prometheus service. This is implemented by generating a configuration file with the addresses of the super-nodes. Prometheus is configured by reading his configuration from this file.\\

\noindent
Lastly, the root-type contains the Grafana dashboard. This service uses a custom designed dashboard, which is publicly available at \url{https://grafana.com/dashboards/10286}. Grafana is configured in such a way that it automatically adds the local Prometheus service as a data source and installs the dashboard mentioned above. The dashboard uses not only existing visualization tools like graphs and singlestat-panels, but it also visualizes the cost and waste data in a custom designed panel.\\

\noindent
This panel is implemented in the typescript programming language and can its source code can be found at \url{https://github.com/dadvisor/containers-panel}. It generates 17 different graphs that can all be used to investigate which services (or group of services) are responsible for consuming the most cost or waste. This can also be generated per resource metric as explained in the pricing model (\autoref{sec:pricing}). The graphs for a demo application are presented in \autoref{sec:demo_app}.

\subsection{node}
The node is the probe that collects information about the host that serves the cloud application. Therefore, the node must be deployed on every host that belongs to the cloud system. To summarize, its responsibilities are the following:
\begin{enumerate}
    \item Inspect internet packets and analyse these to find out which containers are communicating with each other.
    \item Identify the running containers, including their IP addresses.
    \item Communicate with the other nodes for resolving the internet packets.
    \item Collect resource statistics about the running containers
    \item Expose the collected data in a specific format, such that it can be used by Prometheus.
\end{enumerate}

In case of being a supernode, it also needs to known its children for scraping data. Therefore, it needs to communicate with the root to find out this information. Below is a short overview of each of the tasks defined above.

\subsubsection{Identify internet traffic}
The internet traffic monitoring needs to be optimized as much as possible, as it is not unusual to send thousands of packets a second per host. Therefore, several optimizations are used, which are described below.\\

\noindent
First of all, the TCPdump command uses several arguments to filter out messages that cannot be resolved. It's entire command is the following.
\begin{verbatim}
tcpdump -c 1000 -i any -nn ip and -l -t not port 14100 and
tcp and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2))
 != 0)
\end{verbatim}
An explanation of the arguments can be found below:
\begin{itemize}
    \item \textbf{-c 1000}: collect 1000 packets and then stop. This number is configurable.
    \item \textbf{-i any}: Any interface \cite{tcpmanpage}.
    \item \textbf{-nn ip}: Don't convert addresses (i.e., host addresses, port numbers, etc.) to names \cite{tcpmanpage}.
    \item \textbf{-l}: Make the output line buffered.
    \item \textbf{-t}: Don't print the timestamp, as this is not used.
    \item \textbf{not port 14100}: this port is filtered, as this is the default port for communicating with the node. This option can be configured, such that is contains more ports.
    \item \textbf{tcp} Only retrieve TCP data.
    \item \textbf{$(\dots~~!= 0)$}: Filter packets with a content length of 0 \cite{tcpdump-filter}.
\end{itemize}
An example of the output of this command is the following.
\begin{verbatim}
IP 145.97.131.77.53210 > 162.125.34.6.443: Flags [.], seq
865:2293, ack 3662, win 2048, options [nop,nop,TS val
958254525 ecr 4134920334], length 1428
\end{verbatim}
From this line, the following information is extracted:
\begin{itemize}
    \item The source of this TCP packet is: 145.97.131.77 with port 53210.
    \item The destination of this TCP packet is: 162.125.34.6 with port 443.
    \item The content length of this message is 1428 bytes.
\end{itemize}
It is important to understand the IP addresses of the TCP packet, as this reveals the direction of the packet. There are three cases possible:
\begin{itemize}
    \item The source is a remote location and the destination is local. In this case, the destination needs to be resolved into a container ID.
    \item The source is local and the destination is remote. In this case, the source needs to be resolved into a container ID.
    \item Both the source and destination are local. Now, both addresses need to be resolved into a container ID.
\end{itemize}


It uses cAdvisor\footnote{See \url{https://github.com/google/cadvisor}} for collecting statistics about the 
